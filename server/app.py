from flask import Flask, request, jsonify
import json
from flask_cors import CORS
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import base64
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import secrets
from cryptography.hazmat.primitives import padding
import bcrypt
from user_roles import insert_users_roles, user_already_exists, get_user_id, get_users_roles_role_id, get_role
import MySQLdb
import mysql.connector
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity


app = Flask(__name__)

CORS(app)

# Configure JWT settings
app.config['JWT_SECRET_KEY'] = 'I AM INDEED LEARNING REACT AND PYTHON JOB ORIENTED PROGRAM'  # Change this to your secret key
jwt = JWTManager(app)

# MySQL setup
db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="password",
    database="training"
)

# User authentication (login) route
@app.route('/login', methods=['POST'])
def login():
    username = request.json.get('username')
    password = request.json.get('password')
    # Example: validate username and password here
    if username == 'example_user' and password == 'example_password':
        access_token = create_access_token(identity=username)
        return jsonify(access_token=access_token), 200
    else:
        return jsonify({"msg": "Invalid username or password"}), 401
    
# The JWT_SECRET_KEY is configured in the Flask application configuration using app.config['JWT_SECRET_KEY'] = 'your_secret_key_here'.
# The JWTManager object (jwt) is created and initialized with the Flask application (JWTManager(app)).
# When a user logs in (/login route), the create_access_token() function is called to generate a JWT access token. This function automatically uses the JWT_SECRET_KEY configured in the Flask application.
# Similarly, when a user accesses a protected route (/protected route), the @jwt_required() decorator ensures that the JWT token is valid. Again, the JWT_SECRET_KEY is used internally by flask_jwt_extended for token verification.

#The JWT_SECRET_KEY is used implicitly by flask_jwt_extended behind the scenes for token signing and verification, so you don't need to explicitly specify it when creating or verifying tokens. However, it's crucial to configure it securely in your application to ensure the security of JWT-based authentication
    

# A JWT (JSON Web Token) typically consists of three main components: the header, the payload, and the signature. These components are separated by dots (.) and combined to form the JWT token. Here's an overview of each component:

# Header:

# The header typically consists of two parts: the type of token (typ) and the signing algorithm (alg).
# Example: {"typ": "JWT", "alg": "HS256"}
# The header specifies the type of token (which is usually JWT) and the cryptographic algorithm used to secure the token.
# Payload:

# The payload contains the claims or statements about the entity (user) and additional data.
# It consists of a set of key-value pairs, known as claims, that represent information about the user or additional metadata.
# Common claims include iss (issuer), sub (subject), exp (expiration time), iat (issued at), and aud (audience).
# Example: {"sub": "user123", "role": "admin", "exp": 1633348800}
# The payload is encoded using Base64Url encoding to form the middle part of the JWT token.
# Signature:

# The signature is generated by combining the encoded header, encoded payload, and a secret key (or a public/private key pair) using the specified algorithm.
# It ensures the integrity of the JWT token and allows the recipient to verify that the token has not been tampered with.
# The signature is appended to the JWT token, separated by a dot (.).
# Example: HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secretKey)
# When combined, these components form a JWT token in the following format:
    
# Protected route that requires JWT authentication
@app.route('/protected', methods=['GET'])
@jwt_required()
def protected():
    current_user = get_jwt_identity()
    return jsonify(logged_in_as=current_user), 200

@app.route("/api/fetchstates", methods=['GET'])
def fetch_states():

    print("To fetch states from state table")

    cursor = db.cursor()
    #print("db cursor opened")
    sql = f"SELECT state_id, state_name FROM state"
    cursor.execute(sql)
    #print("db cursor executed ")
    results= cursor.fetchall()

    db.commit()
    cursor.close()

    #print("Results :", results)

    return jsonify({"states":results})

@app.route("/api/fetchdistricts", methods=['GET'])
def fetch_districts():
    print("To fetch districts...!")

    state_id = request.args.get('state_id')
    print("request param retrieved :", state_id)

    cursor = db.cursor()
    sql = f"SELECT district_name from district WHERE state_id = %s"
    value = (state_id,)
    cursor.execute(sql, value)
    results= cursor.fetchall()

    db.commit()
    cursor.close()

    #print("Results :", results)

    return jsonify({"districts":results})


@app.route('/api/registration', methods=['POST'])
def registration():

    print('Inside api/registration')
    registrationData = request.get_json()        
    user = registrationData['username']
    userpassword = registrationData['userpassword']   
    email = registrationData['email'] 
    role = registrationData['selectedRole'] 

    password_hash = bcrypt.hashpw(userpassword.encode('utf-8'), bcrypt.gensalt())
   
    try:

        if user_already_exists(db, user) :            
            return jsonify({'error': 'User already exists'}), 409 
        else:
            cursor = db.cursor()
            sql = "INSERT INTO users (username, password_hash, email) VALUES (%s, %s, %s)"
            val = (user, password_hash, email)
            cursor.execute(sql, val)
            db.commit()
            cursor.close()
            #Call users_roles table to update with user roles from users_roles module
            sucess = insert_users_roles(db, user, role)
            if sucess:              
                return jsonify({'message': 'Registration successful with '+sucess}), 200
            else:
                return jsonify({'error': 'Registration Failed with User and Role'}), 200   

    except MySQLdb.Error as e:
        error_code = e.errno  # Get the MySQL error code
        if error_code == 409:
            error_message = "Duplicate entry. User already exists."
        else:
            error_message = "An error occurred during registration."
        return jsonify({"error": error_message}), 400
    except mysql.connector.IntegrityError as e:
        error_code = e.errno  # Get the MySQL error code
        if error_code == 1062:
            error_message = "Duplicate entry. User already exists."
        else:
            error_message = "An error occurred during registration."

        return jsonify({"error": error_message}), 400

    
@app.errorhandler(MySQLdb.Error)
def handle_mysql_error(e):
    return jsonify({'error': 'MySQL Error: ' + str(e)})



@app.route('/')
def hello():
    return 'Hello, Job Oriented Program!'


def generate_key():
    salt = secrets.token_bytes(16)  # Generate a random salt
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,  # 32 bytes for AES-256
        salt=salt,
        iterations=100000,
        backend=default_backend()
    )
    key = kdf.derive(secrets.token_bytes(32))  # Generate a random 32-byte key
    return key

@app.route('/api/encryptdata')
def encrypt():
    encryptdata = request.args.get('encryptdata', default='', type=str)
    key = generate_key()
    print("key :", key)
    backend = default_backend()
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)  # Use ECB mode
    encryptor = cipher.encryptor()
    encryptdata_bytes = encryptdata.encode('utf-8')  # Convert string to bytes

    # Pad the input data using PKCS7 padding
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(encryptdata_bytes) + padder.finalize()

    ciphertext = encryptor.update(padded_data) + encryptor.finalize()
    encrypted_data = base64.b64encode(ciphertext).decode('utf-8')
    print("encryptedData :", encrypted_data)
    return jsonify({"encryptedData": encrypted_data})


@app.route('/api/decryptdata')
def decrypt():
    decryptdata = request.args.get('decryptdata', default='', type=str)
    print("decryptdata:", decryptdata)
    key = generate_key()
    backend = default_backend()
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)  # Use ECB mode
    decryptor = cipher.decryptor()
    ciphertext = base64.b64decode(decryptdata)
    decrypted_data = decryptor.update(ciphertext) + decryptor.finalize()

    # Remove PKCS7 padding
    unpadder = padding.PKCS7(128).unpadder()
    unpadded_data = unpadder.update(decrypted_data) + unpadder.finalize()

    decrypted_data_str = unpadded_data.decode('utf-8')  # Decode bytes to string
    print("decryptedData :", decrypted_data_str)
    return json.dumps({"decryptedData": decrypted_data_str})



@app.route('/api/states')
def get_states():
    states = get_states_from_file()
    if isinstance(states, list):
        print('states',states)
        return jsonify({'states': states})
    else:
        return jsonify({'error': states}), 400

def get_states_from_file():
    try:
        with open('districts.json', 'r') as file:
            data = json.load(file)
            states = [state['state'] for state in data['states']] 
            return states
    except FileNotFoundError:
        return "File containing Indian states not found."
    except Exception as e:
        return f"An error occurred: {str(e)}"

@app.route('/api/districts', methods=['GET'])
def get_districts():
    state_name = request.args.get('state_name', default='', type=str)
    print('state_name',state_name)
    if state_name:
        districts = get_districts_by_state(state_name)
        print('districts',districts)
        if isinstance(districts, list):
            print('districts',districts)
            return jsonify({'districts': districts})
        else:
            return jsonify({'error': districts}), 400
    else:
        return jsonify({'error': 'State name parameter is required'}), 400

def get_districts_by_state(state_name):
    try:
        with open('districts.json', 'r') as file:
            data = json.load(file)
            state_data = next((state for state in data['states'] if state['state'].lower() == state_name.lower()), None)
            if state_data:                
                return state_data['districts']
            else:
                return f"No districts found for the state '{state_name}'"
    except FileNotFoundError:
        return "File containing Indian states and districts not found."
    except Exception as e:
        return f"An error occurred: {str(e)}"



# def get_districts_by_state(state_name):
#     try:
#         with open('districts.json', 'r') as file:
#             data = json.load(file)
#             state_data = next((state for state in data['states'] if state['state'].lower() == state_name.lower()), None)
#             if state_data:
#                 return state_data['districts']
#             else:
#                 return f"No districts found for the state '{state_name}'"
#     except FileNotFoundError:
#         return "File containing Indian states and districts not found."
#     except Exception as e:
#         return f"An error occurred: {str(e)}"
    

# state_name = input("Enter the name of the state within India: ")
# districts = get_districts_by_state(state_name)

# if isinstance(districts, list):
#     print(f"Districts in {state_name}:")
#     for district in districts:
#         print(district)
# else:
#     print(districts)

# data = json.load(file): This line reads the contents of the file object file, which contains JSON data. The json.load() function is used to deserialize the JSON string into a Python dictionary. So, after this line, data contains the deserialized JSON data from the file.

# states = [state['state'] for state in data['states']]: This line is a list comprehension that iterates over the list of states (data['states']) extracted from the JSON data. For each state dictionary in data['states'], it retrieves the value corresponding to the key 'state' and adds it to the list states. So, after this line, states is a list of state names extracted from the JSON data.

# state_data = next((state for state in data['states'] if state['state'].lower() == state_name.lower()), None): This line uses a generator expression within the next() function to find the first state dictionary in data['states'] whose name matches the provided state_name (case-insensitive comparison). If a matching state is found, state_data will be set to that state dictionary. If no matching state is found, state_data will be set to None.

# state for state in data['states']: This part of the expression iterates over each state dictionary in data['states'].
# if state['state'].lower() == state_name.lower(): This part checks if the lowercase version of the state name in the current state dictionary (state['state'].lower()) matches the lowercase version of the provided state_name (state_name.lower()).
# next(...): This function returns the next item from the iterable (the generator expression) that matches the condition specified. If no item matches the condition, it returns the default value None.

@app.route('/')
def index():
    return 'Hello, Score Recorder!'

if __name__ == '__main__':
    #app.run(debug=True)
    app.run(host='127.0.0.1', port=5006) # Change the port as needed