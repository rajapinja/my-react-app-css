from flask import Flask, request, jsonify
import json
from flask_cors import CORS
import base64
import secrets
import bcrypt
# from user_roles import insert_users_roles, user_already_exists, get_user_id, get_users_roles_role_id, get_role
import mysql.connector
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity


app = Flask(__name__)

CORS(app)

# Configure JWT settings
app.config['JWT_SECRET_KEY'] = 'I AM INDEED LEARNING REACT AND PYTHON JOB ORIENTED PROGRAM'  # Change this to your secret key
jwt = JWTManager(app)

# MySQL setup
db = mysql.connector.connect(
    host="flaskdb.c348gyc8yhgg.us-east-1.rds.amazonaws.com",
    user="admin",
    password="admin123",
    database="trainingdb"
)
    
# The JWT_SECRET_KEY is configured in the Flask application configuration using app.config['JWT_SECRET_KEY'] = 'your_secret_key_here'.
# The JWTManager object (jwt) is created and initialized with the Flask application (JWTManager(app)).
# When a user logs in (/login route), the create_access_token() function is called to generate a JWT access token. This function automatically uses the JWT_SECRET_KEY configured in the Flask application.
# Similarly, when a user accesses a protected route (/protected route), the @jwt_required() decorator ensures that the JWT token is valid. Again, the JWT_SECRET_KEY is used internally by flask_jwt_extended for token verification.

#The JWT_SECRET_KEY is used implicitly by flask_jwt_extended behind the scenes for token signing and verification, so you don't need to explicitly specify it when creating or verifying tokens. However, it's crucial to configure it securely in your application to ensure the security of JWT-based authentication
    

# A JWT (JSON Web Token) typically consists of three main components: the header, the payload, and the signature. These components are separated by dots (.) and combined to form the JWT token. Here's an overview of each component:

# Header:

# The header typically consists of two parts: the type of token (typ) and the signing algorithm (alg).
# Example: {"typ": "JWT", "alg": "HS256"}
# The header specifies the type of token (which is usually JWT) and the cryptographic algorithm used to secure the token.
# Payload:

# The payload contains the claims or statements about the entity (user) and additional data.
# It consists of a set of key-value pairs, known as claims, that represent information about the user or additional metadata.
# Common claims include iss (issuer), sub (subject), exp (expiration time), iat (issued at), and aud (audience).
# Example: {"sub": "user123", "role": "admin", "exp": 1633348800}
# The payload is encoded using Base64Url encoding to form the middle part of the JWT token.
# Signature:

# The signature is generated by combining the encoded header, encoded payload, and a secret key (or a public/private key pair) using the specified algorithm.
# It ensures the integrity of the JWT token and allows the recipient to verify that the token has not been tampered with.
# The signature is appended to the JWT token, separated by a dot (.).
# Example: HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secretKey)
# When combined, these components form a JWT token in the following format:


@app.route("/api/fetchstates", methods=['GET'])
def fetch_states():

    print("To fetch states from state table")

    cursor = db.cursor()
    #print("db cursor opened")
    sql = f"SELECT state_id, state_name FROM state"
    cursor.execute(sql)
    #print("db cursor executed ")
    results= cursor.fetchall()

    db.commit()
    cursor.close()

    print("Results :", results)

    return jsonify({"states":results})

@app.route("/api/fetchdistricts", methods=['GET'])
def fetch_districts():
    print("To fetch districts...!")

    state_id = request.args.get('state_id')
    print("request param retrieved :", state_id)

    cursor = db.cursor()
    sql = f"SELECT district_name from district WHERE state_id = %s"
    value = (state_id,)
    cursor.execute(sql, value)
    results= cursor.fetchall()

    db.commit()
    cursor.close()

    print("Results :", results)

    return jsonify({"districts":results})  


@app.route('/')
def hello():
    return 'Hello, Job Oriented Program!'

if __name__ == '__main__':
    #app.run(debug=True)
    #app.run(host='127.0.0.1', port=5006) # Change the port as needed
    app.run()
    #app.run(host='0.0.0.0', port=5006) # Change the port as needed
